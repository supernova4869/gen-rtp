mod mol2;
mod itp;
mod hdb;
mod utils;

use mol2::MOL2;
use hdb::get_adj_h_id;
use itp::Topol;
use std::io;
use std::env;
use std::process::exit;

use crate::utils::get_input;

fn main() {
    // 读取mol2
    println!(" GEN-RTP v0.3: An `rtp` and `hdb` file generator to be used");
    println!(" together with acpype or Sobtop.");
    println!(" Website: https://github.com/supernova4869/gen-rtp");
    println!(" Developed by Jiaxing Zhang, at Tianjin University");
    println!(" Contact me: zhangjiaxing7137@tju.edu.cn");
    println!();
    println!("Input path of `mol2` file, e.g. D:/Conan/Haibara_Ai.mol2");
    println!("(Hint: You can directly load it by `gen-rtp Miyano_Shiho.mol2`)");
    let args: Vec<String> = env::args().collect();
    let mol2_file = match args.len() {
        1 => utils::read_file(),
        2 => args[1].to_owned(),
        _ => {
            println!("Too more arguments.");
            io::stdin().read_line(&mut String::new()).unwrap();
            exit(0)
        }
    };
    println!("Reading mol2 file: {}", mol2_file);
    
    // 修改原子名
    println!("Change heavy atom names to element+id? ([y]/n)");
    let change_name = get_input("y".to_string());
    let change_name = if change_name.starts_with(['y', 'Y']) {
        true
    } else {
        false
    };
    
    // 输入排除列表
    let (prev_atoms, 
         next_atoms, 
         prev_con_atom, 
         next_con_atom,
         prev_con_atom_name,
         next_con_atom_name,
         prev_adj_atom,
         next_adj_atom,
         prev_adj_atom_name,
         next_adj_atom_name) = utils::get_exclude_atoms();
    
    println!("Fixing atom names...");
    let mol2 = &mut MOL2::from(mol2_file.as_str());
    let mol2_bak = &mol2.clone();
    let mut heavy_atom_id = 1;
    for a in &mol2_bak.atoms {
        if a.element.ne("H") {
            // 修改重原子命名为元素名+该元素出现次数
            if change_name {
                mol2.atoms[a.atom_id - 1].atom_name = a.element.to_owned() + heavy_atom_id.to_string().as_str();
                heavy_atom_id += 1;
            }
            if let Some(prev_adj_atom) = prev_adj_atom {
                if a.atom_id == prev_adj_atom {
                    mol2.atoms[prev_adj_atom - 1].atom_name = prev_adj_atom_name.to_owned().unwrap();
                }
            }
            if let Some(next_adj_atom) = next_adj_atom {
                if a.atom_id == next_adj_atom {
                    mol2.atoms[next_adj_atom - 1].atom_name = next_adj_atom_name.to_owned().unwrap();
                }
            }
            // 修改邻接H命名
            let adj_h = get_adj_h_id(mol2, a.atom_id);
            for (i, &h) in adj_h.iter().enumerate() {
                // 根据相连H数量修改H名字
                let h_basename = mol2.get_hbasename(&mol2.atoms[h as usize - 1]);
                mol2.atoms[h as usize - 1].atom_name = match adj_h.len() {
                    1 => h_basename,
                    _ => h_basename + (i + 1).to_string().as_str()
                };
            }
        }
    }
    println!("Finished fixing atom names.");

    // 输出mol2
    let mol2_stem = utils::get_stemname(&mol2_file);
    let parent_path = utils::get_parent_path(&mol2_file);
    let out = parent_path.join(mol2_stem.to_string() + ".mol2");
    mol2.output(out.as_os_str().to_str().unwrap());

    // 读取itp, 更新H原子名, 选择性删除连接原子成键信息
    let itp_file = parent_path.join(mol2_stem.to_string() + ".itp");
    println!("Input the `itp` file name generated by Sobtop (default: {}):", itp_file.to_str().unwrap());
    let inp = utils::get_input(itp_file.to_str().unwrap().to_string());
    let itp_file = match inp.is_empty() {
        true => utils::read_file(),
        false => inp
    };
    let mut itp = Topol::from(itp_file.as_str(), mol2, 
        &prev_atoms, 
        &next_atoms,
        prev_con_atom, 
        next_con_atom,
        &prev_con_atom_name, 
        &next_con_atom_name,
        prev_adj_atom, 
        next_adj_atom,
        &prev_adj_atom_name, 
        &next_adj_atom_name,
    );
    // 输出rtp, 特殊处理2号规则
    let itp_stem = utils::get_stemname(&itp_file);
    let parent_path = utils::get_parent_path(&itp_file);
    let rtp_name = itp_stem.to_string() + ".rtp";
    let out = &parent_path.join(rtp_name);
    let out = out.as_os_str().to_str().unwrap();
    itp.to_rtp(out, "amber", &prev_atoms, &next_atoms);
    // 输出hdb, 根据H类型
    let hdb_name = itp_stem + ".hdb";
    let out = parent_path.join(hdb_name);
    let out = out.as_os_str().to_str().unwrap();
    mol2.to_hdb(out,
        &prev_atoms, 
        &next_atoms, 
        prev_con_atom, 
        next_con_atom,
        &prev_con_atom_name, 
        &next_con_atom_name,
        prev_adj_atom, 
        next_adj_atom,
        &prev_adj_atom_name, 
        &next_adj_atom_name,);

    println!("Press any key to exit");
    io::stdin().read_line(&mut String::new()).expect("Failed to read line");
}
